
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Text File Content</title>
    </head>
    <body>
        <pre>Functional Programming:
	Functional programming means organising the code,
	  separation of functions.
	Separation of data and functions.
	Most common functions are Pure function, map, filter,
	  zip, and reduce.
	
Pure Functions:
	If we give same input, always return same output everytime.
	Function should not produce any side effects.

	def multiply_by2(li):
	  newList = []
	  for item in li:
	    newList.append(item*2)
	  return newList
	print(multiply_by2([1,2,3])) 		// [2,4,6]

	This function always give same output without side effects.

	if the print statement is placed in return condition
	  return print(newList)
	it affect the outside, i.e. it related with outside

	newList = [], should be used inside the function, otherwise
	  it will produce side effects, if some one reassign the value.

Map():
	myList = [1,2,3]
	def multiply_by2(item):
	  return item*2
	print(list(map(multiply_by2, myList)))	// [2,4,6]
	print(myList)				// [1,2,3]
	
	Map doesn't modify mylist variables, return new list.

Filter():
	myList = [1,2,3]
	def check_odd(item):
	  return item % 2 != 0
	print(list(reduce(check_odd, myList)))	// [1,3]
	print(myList)				// [1,2,3]

Zip():
	myList = [1,2,3]
	yourList = [10,20,30]
	print(list(zip(myList, yourList)))	// [(1, 10), (2, 20), (3, 30)]

	Both myList and yourList should be iterable, not be same type
	  may list and tuples, list and set or tuples and set
	we can zip three or more list also zip(, , , , , ,...)

Reduce():
	if we want to use reduce(), we need to import

	from functools import reduce

	myList = [1,2,3]
	def accumulator(acc, item):			// acc = 0
	  return acc + item
	print(reduce(accumulator, myList, 0))		// 6
	print(reduce(accumulator, myList, 10))		// 16

	reduce() reduces the length of the variable in single value.

Lambda expressions:

	lambda param: action(param)
	The above one is logic.

	myList = [1,2,3]
	print(list(map(lambda item: item*2, myList)))		// [2, 4, 6]
	print(list(filter(lambda item: item%2!=0, myList)))	// [1, 3]
	print(list(reduce(lambda acc,item: acc+item, myList)))	// 6

Exercise (Lambda expressions):
	list = [5,4,3]
	print(list(map(lambda item: item**2, list)))		// [25, 16, 9]
	a = [(0,2),(4,3),(9,9),(10,-1)]
	a.sort(key=lambda x: x[1])
	print(a)			// [(10,-1),(0,2),(4,3),(9,9)]

	a.sort() method used above have good logic.

Comprehensions:
	List, set and dictionary are called comprehensions.

	myList = []
	for char in 'hello':
	  myList.append(char)
	print(myList)			// ['h', 'e', 'l', 'l', 'o']


	myList = [char for char in 'hello']
	print(myList)			// ['h', 'e', 'l', 'l', 'o']

	myList2 = [num for num in range(0, 100)]
	print(myList2)			// [0, 1,..., 99]

	myList3 = [num*2 for num in range(0, 100)]
	print(myList3)			// [0, 2, 4,...198]

	myList4 = [num for num in range(0, 100) if num % 2 == 0]
	print(myList4)			// [0, 2, 4,... 98]

	For set, change [] to {}.

	For dictionary:
	  simpleDict = {
		'a': 1,
		'b': 2
		}
	myDict = {key: value**2 for key,value in simpleDict.items()}
	print(myDict)			// {'a':1, 'b':4}

	myDict = {num: num*2 for num in [1,2,3]}
	print(myDict)			// {1:1, 2:4, 3:6}

	If there is any program to remove the duplicate, the use set
	  function that remove the duplicate then convert it to list.



end of part-4</pre>
    </body>
    </html>
    